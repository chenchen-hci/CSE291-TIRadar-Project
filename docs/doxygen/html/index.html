<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Millimeter Wave (mmw) Demo for XWR14XX</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<table width=100%>
<tr>
  <td bgcolor="black" width="1"><a href="http://www.ti.com"><img border=0 src="../../tilogo.gif"></a></td>
  <td bgcolor="red"><img src="../../titagline.gif"></td>
</tr>
</table>
<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li class="current"><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Millimeter Wave (mmw) Demo for XWR14XX </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="intro_sec"></a>
Introduction</h1>
<div class="image">
<img src="toplevel.png" alt="toplevel.png"/>
</div>
<p>The millimeter wave demo shows some of the capabilities of the XWR14xx SoC using the drivers in the mmWave SDK (Software Development Kit). It allows user to specify the chirping profile and displays the detected objects and other information in real-time.</p>
<p>Following is a high level description of the features of this demo:</p><ul>
<li>Be able to specify desired chirping profile through command line interface (CLI) on a UART port or through the TI Gallery App - <b>mmWave Demo Visualizer</b> - that allows user to provide a variety of profile configurations via the UART input port and displays the streamed detected output from another UART port in real-time, as seen in picture above.</li>
<li>Some sample profile configurations have been provided in the demo directory that can be used with CLI directly or via <b>mmWave Demo Visualizer</b>: <pre class="fragment">     mmw/profiles/profile_2d.cfg
     mmw/profiles/profile_3d.cfg
     mmw/profiles/profile_heat_map.cfg</pre></li>
<li>Do 1D, 2D, CFAR, Azimuth and Elevation processing and stream out velocity and three spatial coordinates (x,y,z) of the detected objects in real-time. The demo can also be configured to do 2D only detection (velocity and x,y coordinates).</li>
<li>Various display options besides object detection like azimuth heat map and Doppler-range heat map.</li>
<li>Illustrates how to configure the various hardware entities (Hardware accelerator (HWA), EDMA, UART) in the AR SoC using the driver software.</li>
</ul>
<h1><a class="anchor" id="limit"></a>
Limitations</h1>
<ul>
<li>Because of UART speed limit (&lt; 1 Mbps), the frame time is more restrictive. For example, for the azimuth and Doppler heat maps for 256 FFT range and 16 point FFT Doppler, it takes about 200 ms to transmit.</li>
<li>Present implementation in this demo cannot resolve objects at the same range and velocity but at different azimuth and/or elevation. The algorithms may be improved in future versions to solve this.</li>
<li>Code will give an error if the requested memory in L3 RAM exceeds its size (<a class="el" href="sys__common__xwr14xx_8h.html#af1c45dc4cb3dc2f8de65b4dbb8b36297">SOC_XWR14XX_MSS_L3RAM_SIZE</a>) due to particular combination of CLI configuration parameters.</li>
<li>For most boards, a range bias of few centimeters has been observed. User can estimate the range bias on their board and correct using the calibration procedure described in <a class="el" href="index.html#calibration">Range Bias and Rx Channel Gain/Offset Measurement and Compensation</a>.</li>
<li>For the scheme <a class="el" href="data__path_8h.html#a8db0f12d3b1bb9c6d76e0e5dc26ab1b9a88ff48379dbdf4a48b2a8b1c53799ec5">DATA_PATH_CHAIN_COMBINED_LOGMAG</a>, the azimuth static heat map (Doppler 0 range bins) is computed on the 1D FFT output instead of the required 2D FFT output because of which the heat map will get affected by motion in the scene. This will be corrected in a future release.</li>
</ul>
<h1><a class="anchor" id="tasks"></a>
Software Tasks</h1>
<p>The demo consists of the following (SYSBIOS) tasks:</p><ul>
<li><a class="el" href="main_8c.html#a8e6edefc4a3ce84930e0ef22056ae123">MmwDemo_initTask</a>. This task is created/launched by <a class="el" href="main_8c.html#a840291bc02cba5474a4cb46a9b9566fe">main</a> and is a one-time active task that performs the following sequence:<ol type="1">
<li>Initializes drivers (&lt;driver&gt;_init).</li>
<li>Initializes the MMWave module (MMWave_init)</li>
<li>Creates/launches following three tasks (the <a class="el" href="cli_8c.html#a96a82b05d16ca58d5c4f7ade7f0df74f">CLI_task</a> is launched indirectly by calling <a class="el" href="cli_8c.html#a664861a70519c2c7c5e4091b1a0958f2">CLI_open</a>).</li>
</ol>
</li>
<li><a class="el" href="cli_8c.html#a96a82b05d16ca58d5c4f7ade7f0df74f">CLI_task</a>. This command line interface task provides a simplified 'shell' interface which allows the configuration of the BSS via the mmWave interface (MMWave_config). It parses input CLI configuration commands like chirp profile and GUI configuration. When sensor start CLI command is parsed, it sends <a class="el" href="sensor__mgmt_8c.html#ae485b2dcd6cba75844da1ac1480f441a">MMWDEMO_CLI_SENSORSTART_EVT</a> to <a class="el" href="sensor__mgmt_8c.html#a37f48f25947195ddb98f2490bdeca2f4">MmwDemo_sensorMgmtTask</a> task and then waits for <a class="el" href="sensor__mgmt_8c.html#ababa0a424ae10418e36721cd4e673fe6">MMWDEMO_START_COMPLETED_EVT</a> before accepting new commands over the CLI/UART. When sensor stop CLI command is parsed, it sends <a class="el" href="sensor__mgmt_8c.html#a734fcbf64f0eb0c1dfd9d687ed5f1afa">MMWDEMO_CLI_SENSORSTOP_EVT</a> to <a class="el" href="sensor__mgmt_8c.html#a37f48f25947195ddb98f2490bdeca2f4">MmwDemo_sensorMgmtTask</a> task and then waits for <a class="el" href="sensor__mgmt_8c.html#ad9e9267a2e19827cd8c026128ab40fa5">MMWDEMO_STOP_COMPLETED_EVT</a> before accepting new commands over the CLI/UART.</li>
<li><p class="startli"><a class="el" href="sensor__mgmt_8c.html#a37f48f25947195ddb98f2490bdeca2f4">MmwDemo_sensorMgmtTask</a>. This task accepts sensor start and stop commands either via CLI or GPIO buttons on the EVMs. It performs the following steps on receiving the start and stop commands:</p><ul>
<li>MMWDEMO_CLI_SENSORSTART_EVT:<ol type="1">
<li>Issues MMWave_config using the previously parsed configurations to setup the BSS.</li>
<li>Configures the only-once (<a class="el" href="data__path_8h.html#a1f322283a6721ee9d95a70b23e6fc219">MmwDemo_dataPathConfigCommon</a>) and first-time (<a class="el" href="data__path_8h.html#ace4c5b918f8614a44af79c92a51585c8">MmwDemo_config1D_HWA</a>, <a class="el" href="data__path_8h.html#ac3e6713170066d2366a19285975bd929">MmwDemo_dataPathTrigger1D</a>) data path processing configurations, so that the processing chain is ready to do the first step of 1D processing related to chirps (see <a class="el" href="index.html#datapath">Data Path - Overall</a>).</li>
<li>Issues MMWave_start to command the BSS to start chirping.</li>
<li>Switches on the <a class="el" href="gpio__xwr14xx_8h.html#a149777eec098a6bdd61aa65bdf4cf9ef">SOC_XWR14XX_GPIO_2</a> LED on EVM</li>
<li>Signals the <a class="el" href="sensor__mgmt_8c.html#ababa0a424ae10418e36721cd4e673fe6">MMWDEMO_START_COMPLETED_EVT</a> event to CLI task. <br />
</li>
</ol>
</li>
<li>MMWDEMO_CLI_SENSORSTOP_EVT:<ol type="1">
<li>Issues MMWave_stop to stop the BSS and the chirping</li>
<li>Switches off the <a class="el" href="gpio__xwr14xx_8h.html#a149777eec098a6bdd61aa65bdf4cf9ef">SOC_XWR14XX_GPIO_2</a> LED on EVM</li>
<li>Signals the <a class="el" href="sensor__mgmt_8c.html#ad9e9267a2e19827cd8c026128ab40fa5">MMWDEMO_STOP_COMPLETED_EVT</a> event to CLI task.</li>
</ol>
</li>
</ul>
<p class="startli">Internally, <a class="el" href="sensor__mgmt_8c.html#a37f48f25947195ddb98f2490bdeca2f4">MmwDemo_sensorMgmtTask</a> has a state machine that handles CLI and key requests. The following diagram illustrates the state machine and how state changes upon different events. Also, BSS may trigger the sensor to stop, such as "finite loop frame".</p>
</li>
</ul>
<div class="image">
<img src="sensor_management.png" alt="sensor_management.png"/>
</div>
<ul>
<li><a class="el" href="main_8c.html#a704f8c65125047f85b3ced585f4f58f1">MmwDemo_mmWaveCtrlTask</a>. This task is used to provide an execution context for the mmWave control, it calls in an endless loop the MMWave_execute API.</li>
<li><a class="el" href="main_8c.html#a198c7d7c9ab2a9638d037862c5ec97a4">MmwDemo_dataPathTask</a>. The task performs in real-time:<ul>
<li>Data path processing chain control and (re-)configuration of the hardware entities involved in the processing chain, namely HWA and EDMA.</li>
<li>Transmits the detected objects etc through the UART output port. For format of the data on UART output port, see <a class="el" href="main_8c.html#ac3a90335aea273ffb5d4cc76d780a55d">MmwDemo_transmitProcessedOutput</a>. The UART transmission is done in the data path processing task itself although it could be done in a separate thread to potentially parallelize data path processing with transmission on UART. Presently, the UART processing is dominant because of slow UART speed and data path processing time on R4F CPU is not much (about 2 ms, most work done by HWA) hence this is not a problem. Separation of the transmit task may be done in future versions of the demo.</li>
</ul>
</li>
</ul>
<h1><a class="anchor" id="datapath"></a>
Data Path - Overall</h1>
<div class="image">
<img src="datapath_overall.png" alt="datapath_overall.png"/>
<div class="caption">
Top Level Data Path Processing Chain</div></div>
<p> <br />
 <br />
 </p><div class="image">
<img src="datapath_overall_timing.png" alt="datapath_overall_timing.png"/>
<div class="caption">
Top Level Data Path Timing</div></div>
<p> As seen in the above picture, the data path processing consists of:</p><ul>
<li>Processing during the chirps as seen in the timing diagram:<ul>
<li>This consists of 1D (range) FFT processing that takes input from multiple receive antennae from the ADC buffer for every chirp (corresponding to the chirping pattern on the transmit antennae) and performs FFT on it and generates transposed output into the L3 RAM. This is done using HWA and EDMA, more details of which can be seen in <a class="el" href="index.html#data1d">Data Path - 1st Dimension FFT Processing</a></li>
</ul>
</li>
<li>Processing during the time between the end of chirps until the beginning of the next chirping period, shown as "Inter frame Period" in the timing diagram. This processing consists of:<ul>
<li>2D (velocity) FFT processing that takes input from 1D output in L3 RAM and performs FFT to give a (range,velocity) matrix in the L3 RAM. This is done using HWA and EDMA, more details of which can bbe seen in <a class="el" href="index.html#data2d">Data Path - Lower Precision 2nd Dimension Processing</a></li>
<li>CFAR detection using HWA. More details can be seen at <a class="el" href="index.html#dataCFAR">Data Path - CFAR Detection</a>.</li>
<li>Post processing using R4F. More details can be seen at <a class="el" href="index.html#dataPostProc">Data Path - Post processing</a></li>
<li>Direction of Arrival Estimation (Azimuth, Elevation). More details can be seen at <a class="el" href="index.html#dataAngElev_low">Data Path - Direction of Arrival FFT Calculation corresponding to Lower Precision 2D Processing</a>, <a class="el" href="index.html#dataAngElev_high">Data Path - Direction of Arrival FFT Calculation corresponding to Higher Precision 2D Processing</a> and <a class="el" href="index.html#dataXYZ">Data Path - Direction of Arrival Estimation (x,y,z)</a></li>
</ul>
</li>
</ul>
<h2><a class="anchor" id="antConfig"></a>
Antenna Configurations</h2>
<p>The following figure shows antenna layout as seen from the front of the EVM xWR14xx board alongside the x,y,z coordinate convention. </p><div class="image">
<img src="antenna_design.png" alt="antenna_design.png"/>
<div class="caption">
xWR14xx Antenna layout</div></div>
<p> As seen in figures below, the millimeter wave demo supports two antenna configurations:</p><ul>
<li>Two transmit antennas and four receive antennas. Transmit antennas Tx1 and Tx3 are horizontally spaced at d = 2 Lambda, with their transmissions interleaved in a frame. This configuration allows for azimuth estimation.</li>
<li>Three transmit and four receive antennas . The third Tx antenna, Tx2, is positioned between the other two Tx antennas at half lambda elevation. This configuration allows for both azimuth and elevation estimation. <br />
 <div class="image">
<img src="antenna_layout_2D.png" alt="antenna_layout_2D.png"/>
<div class="caption">
Antenna Configuration 2D (azimuth estimation)</div></div>
 <br />
 <div class="image">
<img src="antenna_layout_3D.png" alt="antenna_layout_3D.png"/>
<div class="caption">
Antenna Configuration 3D (azimuth and elevation estimation)</div></div>
 <br />
 </li>
</ul>
<h2><a class="anchor" id="data1d"></a>
Data Path - 1st Dimension FFT Processing</h2>
<div class="image">
<img src="datapath_1d_elevation.png" alt="datapath_1d_elevation.png"/>
<div class="caption">
Data Path 1D</div></div>
<p> <br />
 </p><div class="image">
<img src="datapath_1d_timing.png" alt="datapath_1d_timing.png"/>
<div class="caption">
Data Path 1D timing diagram</div></div>
<p> Above pictures illustrate a case of 3 *16 = 48 chips per frame and 225 samples per receive antenna per chirp with three transmit antennas as mentioned in <a class="el" href="index.html#antConfig">Antenna Configurations</a>, chirping within the frame with repeating pattern of (Tx1,Tx3,Tx2). This is the 3D profile (velocity and x,y,z) case. There are 4 rx antennas, the samples of which are color-coded and labeled as 1,2,3,4 with unique coloring for each of chirps that are processed in ping-pong manner to parallelize accelerator and EDMA processing with sample acquisition from ADC. The hardware accelerator's parameter RAMs are setup to do 256 point FFTs which operates on the input ADC ping and pong buffers to produce output in M2 and M3 memories of the HWA. Initially the software triggers (<a class="el" href="data__path_8h.html#ac3e6713170066d2366a19285975bd929">MmwDemo_dataPathTrigger1D</a>) the processing by activating HWA's dummy params PARAM_0 (ping) and PARAM_2 (pong) which in turn activate the processing PARAMs PARAM_1 (ping) and PARAM_3 (pong) which are waiting on the ADC full signal. When ADC has samples to process in the ADC buffer Ping or Pong memories, the corresponding processing PARAM will trigger FFT calculation and transfer the FFT output into the M2 or M3 memories. Before ADC samples are sent to FFT engine, a Blackman window is applied to them in the HWA. The completion of FFT also triggers EDMA which has been setup to do a copy with transposition from the M2/M3 memories to the L3 RAM (Radar Cube Matrix, <a class="el" href="struct_mmw_demo___data_path_obj__t.html#ad1588bea668908a0ae95af4530cd42a2">MmwDemo_DataPathObj::radarCube</a>) as shown in the picture. This HWA-EDMA ping-pong processing is done 48/2(ping/pong) = 24 times so that all chirps of the frame are processed. The EDMA is setup so that after processing every chirp, the EDMA B or EDMA D which are chained from EDMA A and EDMA C channels will trigger the HWA's dummy PARAMs. The EDMA C in the picture is setup to give a completion interrupt after the last chirp which notifies software that 1D processing is complete and software can trigger 1D processing again for the next chirping period when the time comes. The shadow (link) PaRAMs of EDMA are used for reloading the PaRAMs so reprogramming is avoided. The blue arrows between EDMA blocks indicate linking and red arrows indicate chaining.</p>
<p>In the above pictures:</p><ul>
<li>A is <a class="el" href="data__path_8h.html#a9ea2bc9501d4a3f034c07353f0409f33">MMW_EDMA_1D_PING_CH_ID</a></li>
<li>B is <a class="el" href="data__path_8h.html#ad57f0bf010b68a4c55befc6f4be39af8">MMW_EDMA_1D_PING_CHAIN_CH_ID</a></li>
<li>A_shadow is <a class="el" href="data__path_8h.html#a5a2b5df042bb9d9cb859783248f9ba41">MMW_EDMA_1D_PING_SHADOW_LINK_CH_ID</a></li>
<li>B_shadow is <a class="el" href="data__path_8h.html#af4e3e44ca03cff7108f3e3c78f630c1b">MMW_EDMA_1D_PING_ONE_HOT_SHADOW_LINK_CH_ID</a></li>
<li>C is <a class="el" href="data__path_8h.html#a04bb397e82be5ed3a8d157cd91b30eca">MMW_EDMA_1D_PONG_CH_ID</a>,</li>
<li>D is <a class="el" href="data__path_8h.html#a5284b90b4cc4e436105b3fa6b7565ebc">MMW_EDMA_1D_PONG_CHAIN_CH_ID</a></li>
<li>C_shadow is <a class="el" href="data__path_8h.html#ac52ad8bf7589c6e463b691f0c4de376f">MMW_EDMA_1D_PONG_SHADOW_LINK_CH_ID</a></li>
<li>D_shadow is <a class="el" href="data__path_8h.html#acded0226d26a0ba2279bc973d07a597e">MMW_EDMA_1D_PONG_ONE_HOT_SHADOW_LINK_CH_ID</a></li>
</ul>
<h2><a class="anchor" id="data2d"></a>
Data Path - Lower Precision 2nd Dimension Processing</h2>
<div class="image">
<img src="datapath_2d_top_level.png" alt="datapath_2d_top_level.png"/>
<div class="caption">
Data Path 2D FFT high level diagram</div></div>
<p> <br />
 <br />
 </p><div class="image">
<img src="datapath_2d_timing.png" alt="datapath_2d_timing.png"/>
<div class="caption">
Data Path 2D FFT timing diagram</div></div>
<p>As shown in the high level diagram above, the 2D processing performs a 2nd dimension (Doppler) FFT on the range data from 1D output, the processing is done in a ping-pong manner. It consists of the following steps:</p><ol type="1">
<li>Static clutter removal if enabled. For each range bin, per each antenna, the mean value of the samples is calculated and subtracted from the samples. The operation is performed by R4F directly on data in L3.</li>
<li>The data from the L3 RAM (<a class="el" href="struct_mmw_demo___data_path_obj__t.html#ad1588bea668908a0ae95af4530cd42a2">MmwDemo_DataPathObj::radarCube</a>) is transferred by EDMA into the M0 (even pair or ping) and M1 (odd pair or pong) memories of the HWA which then performs the 2D-FFT and produces the output in M2 and M3 memories. Before FFT operation, input samples are multiplied by a window function.</li>
<li>The HWA performs log magnitude operation on M2 and M3 memories from above step and produces results in M0 and M1. The log magnitude output is in Q11 format.</li>
<li>The HWA performs the sum operation on the M0 and M1 memories from above step and produces results in the M2 and M3 memories appended to results from step 1. The sum is done using FFT in HWA, the sum is obtained in the DC(0th) bin. This FFT programming has srcScale of 2, meaning 2 redundant bits (sign extension, in this case unsigned) are added to MSB and 6 LSBs are padded with 0, so input before computation is in Q17 format. The dstScale is set to 8, so summation output will have 8-bits dropped, giving a result in Q[17-8] = Q9 format. The FFT size is the next power of 2 of number of virtual antennas and the FFT is programmed to enable all butterfly scaling stages, hence the FFT output will be 1/N' * sum(.), where N' = 2^ceil(log2(numVirtualAntennas)) The true average is 1/numVirtualAntennas * sum(.). So when CFAR threshold is programmed, an additional correction factor is required, particularly when number of virtual antennas is not power of 2, e.g when elevation is enabled, the number of virtual antennas is 12.</li>
<li>The EDMA copies the results from step 1 to the L3 RAM at <a class="el" href="struct_mmw_demo___data_path_obj__t.html#ad1588bea668908a0ae95af4530cd42a2">MmwDemo_DataPathObj::radarCube</a> (in the same place as the input in step 1) and then the EDMA copies the results from the previous step to the L3 RAM at <a class="el" href="struct_mmw_demo___data_path_obj__t.html#a3b34b26bcf3a05b5725534bfab01e98b">MmwDemo_DataPathObj::rangeDopplerLogMagMatrix</a>.</li>
</ol>
<p>The data is transferred and processed in chunks of <a class="el" href="data__path_8h.html#a154a01e7d6dd448c2fc228a0d71962e8">MMW_NUM_RANGE_BINS_PER_TRANSFER</a> rows. The timing of ping-pong parallelism is shown in the timing diagram above. For more details of the data flow like the format of data in the memories between stages, the EDMA and HWA resources, etc, refer to the detailed diagram below. </p><div class="image">
<img src="datapath_2d_detailed_elevation.png" alt="datapath_2d_detailed_elevation.png"/>
<div class="caption">
Data Path 2D FFT detailed diagram</div></div>
<p> In the detailed diagram:</p><ul>
<li>A is <a class="el" href="data__path_8h.html#a367acba21316f5eccf1a893509ca1a91">MMW_EDMA_2D_PING_CHAIN_CH_ID2</a>,</li>
<li>B is <a class="el" href="data__path_8h.html#a47e3205760134cb946e20978e7a2603f">MMW_EDMA_2D_PING_CHAIN_CH_ID3</a></li>
<li>A_shadow is <a class="el" href="data__path_8h.html#aa1d6048ae6635cef20c2b9405fb987c4">MMW_EDMA_2D_PING_SHADOW_LINK_CH_ID3</a></li>
<li>B_shadow is <a class="el" href="data__path_8h.html#a1dca197b21e77df550dc63969212c89a">MMW_EDMA_2D_PING_SHADOW_LINK_CH_ID4</a></li>
<li>C is <a class="el" href="data__path_8h.html#aa9a66ddb56efe6260a29befa1f283026">MMW_EDMA_2D_PONG_CHAIN_CH_ID2</a>,</li>
<li>D is <a class="el" href="data__path_8h.html#a763c58032699c06b6d6dd59e6effe9dd">MMW_EDMA_2D_PONG_CHAIN_CH_ID3</a></li>
<li>C_shadow is <a class="el" href="data__path_8h.html#a9e52bd20c50581c2db0fed16c6fdc251">MMW_EDMA_2D_PONG_SHADOW_LINK_CH_ID3</a></li>
<li>D_shadow is <a class="el" href="data__path_8h.html#ac304d6e38211600c9a68061e5fd70a09">MMW_EDMA_2D_PONG_SHADOW_LINK_CH_ID4</a></li>
<li>E is <a class="el" href="data__path_8h.html#ae03fe556dbbcbac4efff5e36067b3666">MMW_EDMA_2D_PING_CH_ID</a>,</li>
<li>F is <a class="el" href="data__path_8h.html#a5d5eeb4f418dbbf6a309d06aec073dd0">MMW_EDMA_2D_PING_CHAIN_CH_ID1</a> (chained to A)</li>
<li>E_shadow is <a class="el" href="data__path_8h.html#a9b442c57a763659b1970d368c8f120e0">MMW_EDMA_2D_PING_SHADOW_LINK_CH_ID1</a></li>
<li>F_shadow is <a class="el" href="data__path_8h.html#a2e68c8242836c4cf324e8ca97e81f4aa">MMW_EDMA_2D_PING_SHADOW_LINK_CH_ID2</a></li>
<li>G is <a class="el" href="data__path_8h.html#ab13716c31e4eda905c60023cdd928e21">MMW_EDMA_2D_PONG_CH_ID</a>,</li>
<li>H is <a class="el" href="data__path_8h.html#af08e07fb9455bb7b4854f1302cc1a8a9">MMW_EDMA_2D_PONG_CHAIN_CH_ID1</a> (chained to C)</li>
<li>G_shadow is <a class="el" href="data__path_8h.html#a9aa02d380b212a2c676899aab9e84218">MMW_EDMA_2D_PONG_SHADOW_LINK_CH_ID1</a></li>
<li>H_shadow is <a class="el" href="data__path_8h.html#aa2ee8a75b3558cea54fc263f2ea143a8">MMW_EDMA_2D_PONG_SHADOW_LINK_CH_ID2</a></li>
</ul>
<p>The 2D processing is triggered by software by starting EDMA A and EDMA C. (<a class="el" href="data__path_8c.html#a062b82bfa3c50667340f5a0b057571c7">MmwDemo_dataPathTrigger2D</a>). <br />
 <br />
 </p>
<h2><a class="anchor" id="data2dCombined2DandLogMag"></a>
Data Path - Higher precision 2nd Dimension Processing</h2>
<p>In the data path processing described above (<a class="el" href="index.html#data2d">Data Path - Lower Precision 2nd Dimension Processing</a>), the FFT output is of 24-bit precision but is converted to 16-bit for storage in radar Cube and this 16-bit is also used for log2 processing. Reason for this scheme is limited storage space in radar cube. However, this loss of precision results in spiky noise profile which increases false detections in CFAR. One way to solve this problem would be to store output of FFT in the M memory as 32-bit instead of 16-bit before log2 operation. However, this requires storage (in bytes) = 3 (num tx antennas) * 4 (num rx antennas) * 8 (complex 32-bit) * Doppler FFT size. This must fit in the 16 KB size for each of the four M memories, which limits the Doppler FFT size to 512, but we support up to 1024. Hence we have to choose the option in HWA to chain the FFT and log magnitude directly without going to M memory, this retains the 24-bit precision. However this comes at the cost of recomputing the 2D FFT during DOA calculation. So it is a trade-off between precision and MIPS. By default, this higher precision scheme is selected but user can change to the lower precision scheme by changing the following line of code in <a class="el" href="main_8c.html" title="This is the main file which implements the millimeter wave Demo. ">main.c</a> to set the left hand side variable to <a class="el" href="data__path_8h.html#a8db0f12d3b1bb9c6d76e0e5dc26ab1b9abaeb99736330c512126425d16b24d23e">DATA_PATH_CHAIN_SEPARATE_LOGMAG</a>. </p><pre class="fragment">    gMmwMCB.dataPathObj.datapathChainSel = DATA_PATH_CHAIN_COMBINED_LOGMAG;</pre><p>The following diagram shows the modified data Path 2D FFT. Since 2D FFT output is not stored in Radar Cube, the Radar Cube still contains 1D FFT data.</p>
<div class="image">
<img src="datapath_2d_detailed_combinedFFTandLogMagnitude.png" alt="datapath_2d_detailed_combinedFFTandLogMagnitude.png"/>
<div class="caption">
Data Path 2D FFT detailed diagram - combined 2D FFT and Log-Magnitude</div></div>
<p>In the detailed diagram:</p><ul>
<li>A is <a class="el" href="data__path_8h.html#a367acba21316f5eccf1a893509ca1a91">MMW_EDMA_2D_PING_CHAIN_CH_ID2</a>,</li>
<li>B is <a class="el" href="data__path_8h.html#a47e3205760134cb946e20978e7a2603f">MMW_EDMA_2D_PING_CHAIN_CH_ID3</a></li>
<li>A_shadow is <a class="el" href="data__path_8h.html#aa1d6048ae6635cef20c2b9405fb987c4">MMW_EDMA_2D_PING_SHADOW_LINK_CH_ID3</a></li>
<li>B_shadow is <a class="el" href="data__path_8h.html#a1dca197b21e77df550dc63969212c89a">MMW_EDMA_2D_PING_SHADOW_LINK_CH_ID4</a></li>
<li>C is <a class="el" href="data__path_8h.html#aa9a66ddb56efe6260a29befa1f283026">MMW_EDMA_2D_PONG_CHAIN_CH_ID2</a>,</li>
<li>D is <a class="el" href="data__path_8h.html#a763c58032699c06b6d6dd59e6effe9dd">MMW_EDMA_2D_PONG_CHAIN_CH_ID3</a></li>
<li>C_shadow is <a class="el" href="data__path_8h.html#a9e52bd20c50581c2db0fed16c6fdc251">MMW_EDMA_2D_PONG_SHADOW_LINK_CH_ID3</a></li>
<li>D_shadow is <a class="el" href="data__path_8h.html#ac304d6e38211600c9a68061e5fd70a09">MMW_EDMA_2D_PONG_SHADOW_LINK_CH_ID4</a></li>
<li>E is <a class="el" href="data__path_8h.html#ae03fe556dbbcbac4efff5e36067b3666">MMW_EDMA_2D_PING_CH_ID</a> (chained to A),</li>
<li>E_shadow is <a class="el" href="data__path_8h.html#a9b442c57a763659b1970d368c8f120e0">MMW_EDMA_2D_PING_SHADOW_LINK_CH_ID1</a></li>
<li>G is <a class="el" href="data__path_8h.html#ab13716c31e4eda905c60023cdd928e21">MMW_EDMA_2D_PONG_CH_ID</a> (chained to C),</li>
<li>G_shadow is <a class="el" href="data__path_8h.html#a9aa02d380b212a2c676899aab9e84218">MMW_EDMA_2D_PONG_SHADOW_LINK_CH_ID1</a></li>
</ul>
<p>The 2D processing is triggered by software by starting EDMA A and EDMA C. (<a class="el" href="data__path_8c.html#a062b82bfa3c50667340f5a0b057571c7">MmwDemo_dataPathTrigger2D</a>). <br />
 <br />
 </p>
<h2><a class="anchor" id="dataCFAR"></a>
Data Path - CFAR Detection</h2>
<div class="image">
<img src="datapath_cfar.png" alt="datapath_cfar.png"/>
<div class="caption">
Data Path CFAR Detection Diagram</div></div>
<p> <br />
 As shown in the above picture, CFAR processing consists of:</p><ol type="1">
<li>The software triggers (<a class="el" href="data__path_8c.html#a099a775772d65f4eabf339a23330e012">MmwDemo_dataPathTriggerCFAR</a>) the EDMA that transfers the range-doppler log magnitude matrix from L3 RAM <a class="el" href="struct_mmw_demo___data_path_obj__t.html#a3b34b26bcf3a05b5725534bfab01e98b">MmwDemo_DataPathObj::rangeDopplerLogMagMatrix</a> (output of 2D processing) to the M0 memory.</li>
<li>The HWA performs CFAR computation in M0 and produces output in M2 memory and a CFAR completion interrupt from HWA is generated to the R4F CPU.</li>
</ol>
<p>In the above picture:</p><ul>
<li>A is <a class="el" href="data__path_8h.html#a08cfb2f031bd21311bfcbd56fe4aaf59">MMW_EDMA_CFAR_INP_CH_ID</a></li>
<li>B is <a class="el" href="data__path_8h.html#aea80908c9fb34c914eeee0d933408c29">MMW_EDMA_CFAR_INP_CHAIN_CH_ID</a></li>
<li>A_Shadow is <a class="el" href="data__path_8h.html#a34924a308694a1212623af6df1ebf7ea">MMW_EDMA_CFAR_INP_SHADOW_LINK_CH_ID1</a></li>
<li>B_Shadow is <a class="el" href="data__path_8h.html#a550c436793a54e1dcc7d6f41145326fb">MMW_EDMA_CFAR_INP_SHADOW_LINK_CH_ID2</a></li>
</ul>
<p>The following are default CFAR configuration parameters:</p><ul>
<li><a class="el" href="data__path_8h.html#ad25c61374974267f66e1314be8a11e2b">MMW_HWA_NOISE_AVG_MODE</a></li>
<li><a class="el" href="data__path_8h.html#a8b54c94e5671bf87b5f0508a82212623">MMW_HWA_CFAR_THRESHOLD_SCALE</a></li>
<li><a class="el" href="data__path_8h.html#abd81ff49cd8e6067bf1cd755ef558012">MMW_HWA_CFAR_WINDOW_LEN</a></li>
<li><a class="el" href="data__path_8h.html#ab5d995f27899827a83196ab55452061f">MMW_HWA_CFAR_GUARD_LEN</a></li>
<li><a class="el" href="data__path_8h.html#ab12a4ba4f59dd7ae538cf77f54ee7d34">MMW_HWA_CFAR_NOISE_DIVISION_RIGHT_SHIFT</a></li>
<li><a class="el" href="data__path_8h.html#a9218047a9d4b231760f06b45b4707b8b">MMW_HWA_CFAR_PEAK_GROUPING</a></li>
</ul>
<p>These parameters can be changed using a cli configuration command cfarCfg. The command with the arguments are described below:</p>
<p>cfarCfg &lt;averageMode&gt; &lt;winLen&gt; &lt;guardLen&gt; &lt;noiseDiv&gt; &lt;cyclicMode&gt; &lt;peakGrouping&gt; &lt;thresholdScale&gt;</p>
<p>where</p><ul>
<li>&lt;averageMode&gt; - 0-CFAR_CA, 1-CFAR_CAGO, 2-CFAR_CASO</li>
<li>&lt;winLen&gt; - CFAR Noise averaging window length</li>
<li>&lt;guardLen&gt; - CFAR guard length</li>
<li>&lt;noiseDiv&gt; - CFAR noise averaging divisor (right shift value)</li>
<li>&lt;cyclicMode&gt; - 0-cyclic mode disabled, 1-cyclic mode enabled</li>
<li>&lt;peakGrouping&gt; - 0-peak grouping disabled, 1-peak grouping enabled</li>
<li>&lt;thresholdScale&gt; - Detection scale factor</li>
</ul>
<p>Note: As mentioned in section <a class="el" href="index.html#data2d">Data Path - Lower Precision 2nd Dimension Processing</a> (and this also applies to higher precision processing chain in <a class="el" href="index.html#data2dCombined2DandLogMag">Data Path - Higher precision 2nd Dimension Processing</a>), the sum output which is input to CFAR is in Q9 format, so the CFAR thresholdScale above also needs to be in Q9 format. Also, if CFAR threshold is originally intended to be expressed in dB (e.g for user friendliness), then we need to do some translation before feeding to the HWA CFAR. This can be derived as follows: <br />
Let N be the number of virtual antennas and N' = 2^ceil(log2(N)) (see <a class="el" href="index.html#data2d">Data Path - Lower Precision 2nd Dimension Processing</a> for N') and user friendly CFAR threshold in dB is TdB (= 20*log10(|.|)). CFAR needs to do in general: <br />
CUT = 1/N * sum(log10(|.|)) &gt; TdB/20 + average of noise terms [similar looking to CUT on LHS] <br />
Given log10(|.|) = log2(|.|)/log2(10), and further adjusting the terms to do computation similar to match what is the sum output described in <a class="el" href="index.html#data2d">Data Path - Lower Precision 2nd Dimension Processing</a> : <br />
2^9 * 1/ N' * sum(log2(|.|)) &gt; TdB/20*log2(10)*2^9 + average of noise terms [similar looking to CUT on LHS] <br />
So the threshold to be provided to the HWA (which comes from the CLI) is <br />
Tcli = 512 * TdB / 6 * N / N'</p>
<h2><a class="anchor" id="dataPostProc"></a>
Data Path - Post processing</h2>
<p>Post processing includes peak grouping and Doppler phase shift compensation.</p>
<p>Peak grouping function (<a class="el" href="post__processing_8h.html#a47e50106eb7aae7af8db7f379d91c03a">MmwDemo_peakGrouping</a>) is done by the R4F CPU after CFAR processing. Its inputs are:</p><ul>
<li>List of detected objects by CFAR Detection from the 2D output in M2. Each detected object is described by three parameters: range index, Doppler index, and noise energy in CFAR cell, as seen in <a class="el" href="data__path_8h.html#a16f0ee49e3b6e93b1911bddbb137ec8c">cfarDetOutput_t</a>.</li>
<li>Radar cubed matrix, located in L3 memory (<a class="el" href="struct_mmw_demo___data_path_obj__t.html#ad1588bea668908a0ae95af4530cd42a2">MmwDemo_DataPathObj::radarCube</a>).</li>
<li>Log magnitude range Doppler matrix in L3 memory (<a class="el" href="struct_mmw_demo___data_path_obj__t.html#a3b34b26bcf3a05b5725534bfab01e98b">MmwDemo_DataPathObj::rangeDopplerLogMagMatrix</a>).</li>
</ul>
<p>The function performs the following:</p><ol type="1">
<li>Discards detected objects with range indices outside of the range specified by peakGrouping CLI command.</li>
<li>Discards detected objects whose FFT peaks in the range-doppler matrix (<a class="el" href="struct_mmw_demo___data_path_obj__t.html#a3b34b26bcf3a05b5725534bfab01e98b">MmwDemo_DataPathObj::rangeDopplerLogMagMatrix</a>) are smaller than its neighbors.</li>
<li>For each selected object, copies the 2nd Dimensional FFT complex values of received virtual antennas located in <a class="el" href="struct_mmw_demo___data_path_obj__t.html#ad1588bea668908a0ae95af4530cd42a2">MmwDemo_DataPathObj::radarCube</a> to M0 (azimuth antennas) and M1 (elevation antennas) for further azimuth and elevation FFT calculation.</li>
<li>For each selected object, copies its (range, Doppler) indices to R4F CPU's local memory <a class="el" href="struct_mmw_demo___data_path_obj__t.html#ace23b31b37f92fccf90a9fee64f4c3c6">MmwDemo_DataPathObj::objOut</a>, which will be eventually shipped out after the azimuth and x,y,z calculations are done (refer to <a class="el" href="index.html#dataXYZ">Data Path - Direction of Arrival Estimation (x,y,z)</a>).</li>
</ol>
<p>Doppler compensation function (<a class="el" href="post__processing_8h.html#a893c939bd1fee908ef9a5ca472615d67">MmwDemo_dopplerCompensation</a>) is done by the R4F CPU after CFAR and peak grouping processing.</p>
<p>Its inputs are separate Azimuth and Elevation symbol arrays.</p>
<p>It performs compensation for the Doppler phase shift on the symbols corresponding to the virtual Rx antennas. In case of 2Tx MIMO scheme, the second set of Rx symbols is rotated by half of the estimated Doppler phase shift between subsequent chirps corresponding to the same Tx antenna. In case of 3Tx MIMO elevation scheme, the second set of Rx symbols is rotated by third of the estimated Doppler phase shift, while the third set of Rx symbols corresponding to the third Tx antenna is rotated by 2/3 of the estimated Doppler phase shift. Refer to the pictures below. <a class="anchor" id="Figure_doppler"></a> </p><div class="image">
<img src="angle_doppler_compensation.png" alt="angle_doppler_compensation.png"/>
<div class="caption">
Figure_doppler: Doppler Compensation</div></div>
<p> At the end, the function returns the number of selected objects.</p>
<h2><a class="anchor" id="dataAngElev_low"></a>
Data Path - Direction of Arrival FFT Calculation corresponding to Lower Precision 2D Processing</h2>
<div class="image">
<img src="datapath_azimuth_fft.png" alt="datapath_azimuth_fft.png"/>
</div>
<p>Azimuth/elevation FFT computation is triggered by the software (<a class="el" href="data__path_8h.html#a6e1da84b2606d49e662ea15521dfac43">MmwDemo_dataPathTriggerAngleEstimation</a>) if the number of detected peaks after the post processing stage is greater than zero. For each detected object in M0 (azimuth antennas) and M1 (elevation antennas), it performs the following steps:</p><ol type="1">
<li>Complex FFT of the array of elevation antennas from M1 to M3.</li>
<li>Complex FFT of the array of azimuth antennas from M0 to M2.</li>
<li>Log magnitude FFT of the array azimuth antennas from M0 to M1 (over-writes the input of step 1). This step is performed for the purpose of finding the peak. The position of the peak is used to look-up the output of calculations in above two steps to obtain the azimuth and elevation peak points which are referred in <a class="el" href="index.html#dataXYZ">Data Path - Direction of Arrival Estimation (x,y,z)</a> as <img class="formulaInl" alt="$P_1$" src="form_0.png"/> and <img class="formulaInl" alt="$P_2$" src="form_1.png"/> respectively.</li>
</ol>
<p>Currently the size of FFT is hardcoded and defined by <a class="el" href="data__path_8h.html#a95442efb4452ea2af94dd34f70ef5515">MMW_NUM_ANGLE_BINS</a>. If the number of Tx elevation antennas is equal to zero (no elevation), only step 2 above is done.</p>
<h2><a class="anchor" id="dataAngElev_high"></a>
Data Path - Direction of Arrival FFT Calculation corresponding to Higher Precision 2D Processing</h2>
<div class="image">
<img src="datapath_alternative.png" alt="datapath_alternative.png"/>
</div>
<p>For higher precision 2D processing, recall that in 2D FFT phase, <br />
</p><ul>
<li>HWA calculates log Magnitude together with 2D FFT without output formating into 16 bits data to preserve resolution for CFAR detection.</li>
<li>It saves only rangeDoppler Matrix and leaves radar cube filled with 1D FFT data.</li>
</ul>
<p>After CFAR and peak grouping phase, <br />
</p><ul>
<li>2D FFT is recalculated for the detected objects.</li>
<li>The rest of the Angle estimation and Elevation estimation are the same as in <a class="el" href="index.html#dataAngElev_low">Data Path - Direction of Arrival FFT Calculation corresponding to Lower Precision 2D Processing</a>.</li>
</ul>
<p>In the diagram:</p><ul>
<li>A is <a class="el" href="data__path_8h.html#a534924a542d0e15f46da39fd8035fccf">MMW_EDMA_2DFFT_SINGLERBIN_CH_ID</a>,</li>
<li>B is <a class="el" href="data__path_8h.html#a5f469afa04e513f553341ec6bf03d1cd">MMW_EDMA_2DFFT_SINGLERBIN_CHAIN_CH_ID</a></li>
<li>A_shadow is <a class="el" href="data__path_8h.html#ac26fc7f3889ef8641b6ac58911a30ce7">MMW_EDMA_2DFFT_SINGLERBIN_SHADOW_LINK_CH_ID</a></li>
<li>B_shadow is <a class="el" href="data__path_8h.html#aadf90102f39369a1d8b6638552693056">MMW_EDMA_2DFFT_SINGLERBIN_SHADOW_LINK_CH_ID2</a></li>
</ul>
<h2><a class="anchor" id="dataXYZ"></a>
Data Path - Direction of Arrival Estimation (x,y,z)</h2>
<p>This processing is done on R4F CPU in the function <a class="el" href="post__processing_8h.html#a6bb97b5fdde222074fb245d05ed7f9e1">angleEstimationAzimElev</a>. <a class="anchor" id="Figure_geometry"></a> </p><div class="image">
<img src="coordinate_geometry.png" alt="coordinate_geometry.png"/>
<div class="caption">
Figure A: Coordinate Geometry</div></div>
<p> <br />
<a class="anchor" id="Figure_wz"></a> </p><div class="image">
<img src="coordinate_geometry_wz.png" alt="coordinate_geometry_wz.png"/>
<div class="caption">
Figure wz</div></div>
<p> <br />
<a class="anchor" id="Figures_wx"></a> </p><div class="image">
<img src="coordinate_geometry_wx.png" alt="coordinate_geometry_wx.png"/>
<div class="caption">
Figures wx</div></div>
<p> <a class="el" href="index.html#Figure_geometry">Figure_geometry</a> shows orientation of x,y,z axes with respect to the sensor/antenna positions. The objective is to estimate the (x,y,z) coordinates of each detected object. <img class="formulaInl" alt="$w_x$" src="form_2.png"/> is the phase difference between consecutive receive azimuth antennas of the 2D FFT and <img class="formulaInl" alt="$w_z$" src="form_3.png"/> is the phase difference between azimuth and corresponding elevation antenna above the azimuth antenna. The phases for each antenna are shown in the <a class="el" href="index.html#Figure_doppler">Figure_doppler</a>. <a class="el" href="index.html#Figure_wz">Figure_wz</a> shows that the distance AB which represents the relative distance between wavefronts intersecting consecutive elevation antennas is <img class="formulaInl" alt="$AB = \frac{\lambda}{2} \sin (\phi)$" src="form_4.png"/>. Therefore <img class="formulaInl" alt="$W_z = \frac{2\pi}{\lambda} \cdot AB$" src="form_5.png"/>, therefore <img class="formulaInl" alt="$W_z = \pi \sin (\phi)$" src="form_6.png"/>. Note that the phase of the lower antenna is advanced compared to the upper antenna which is why picture X shows -Wz term in the upper antenna. <a class="el" href="index.html#Figures_wx">Figures_wx</a> show that distance CD which represents the relative distance between wavefronts intersecting consecutive azimuth antennas is <img class="formulaInl" alt="$CD = \frac{\lambda}{2} \sin (\theta) \cos (\phi)$" src="form_7.png"/> Therefore <img class="formulaInl" alt="$w_x = \frac{2\pi}{\lambda} \cdot CD$" src="form_8.png"/>, therefore <img class="formulaInl" alt="$w_x = \pi \sin (\theta) \cos (\phi)$" src="form_9.png"/>. For a single obstacle, the signal at the 8 azimuth antennas will be ( <img class="formulaInl" alt="$A_1$" src="form_10.png"/> and <img class="formulaInl" alt="$\psi$" src="form_11.png"/> are the arbitrary starting amplitude/phase at the first antenna): </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ A_1 e^{j\psi} [ 1 \; e^{jw_x} \; e^{j2w_x} \; e^{j3w_x} \; e^{j4w_x} \; e^{j5w_x} \; e^{j6w_x} \; e^{j7w_x} ] \]" src="form_12.png"/>
</p>
<p>An FFT of the above signal will yield a peak <img class="formulaInl" alt="$P_1$" src="form_0.png"/> at <img class="formulaInl" alt="$w_x$" src="form_2.png"/>, with the phase of this peak being <img class="formulaInl" alt="$\psi$" src="form_11.png"/> i.e </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ P_1 = A_1 e^{j\psi} \]" src="form_13.png"/>
</p>
<p> If <img class="formulaInl" alt="$k_{MAX}$" src="form_14.png"/> is the index of the peak in log magnitude FFT represented as signed index in range <img class="formulaInl" alt="$[-\frac{N}{2}, \frac{N}{2}-1]$" src="form_15.png"/>, then <img class="formulaInl" alt="$ w_x $" src="form_16.png"/> will be </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ w_x = \frac{2\pi}{N}k_{MAX} \]" src="form_17.png"/>
</p>
<p>The signal at the 4 elevation antennas will be: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ A_2 e^{j(\psi + 2 w_x - w_z)} [ 1 \; e^{jw_x} \; e^{j2w_x} \; e^{j3w_x}] \]" src="form_18.png"/>
</p>
<p>An FFT of the above signal will yield a peak <img class="formulaInl" alt="$P_2$" src="form_1.png"/> at <img class="formulaInl" alt="$w_x$" src="form_2.png"/>, with the phase of this peak being <img class="formulaInl" alt="$\psi + 2w_x - w_z$" src="form_19.png"/>. </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ P_2 = A_2 e^{j(\psi+ 2 w_x - w_z)} \]" src="form_20.png"/>
</p>
<p>From above, </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ P_1 \cdot P_2^* = A_1 \cdot A_2 e^{j(\psi - (\psi+ 2 w_x - w_z))} \]" src="form_21.png"/>
</p>
<p>Therefore, </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ w_z=\angle (P_1 \cdot P_2^* \cdot e^{j2w_x}) \]" src="form_22.png"/>
</p>
<p>Calculate range (in meters) as: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ R=k_r\frac{c \cdot F_{SAMP}}{2 \cdot S \cdot N_{FFT}} \]" src="form_23.png"/>
</p>
<p> where, <img class="formulaInl" alt="$c$" src="form_24.png"/> is the speed of light (m/sec), <img class="formulaInl" alt="$k_r$" src="form_25.png"/> is range index, <img class="formulaInl" alt="$F_{SAMP}$" src="form_26.png"/> is the sampling frequency (Hz), <img class="formulaInl" alt="$S$" src="form_27.png"/> is chirp slope (Hz/sec), <img class="formulaInl" alt="$N_{FFT}$" src="form_28.png"/> is 1D FFT size. Based on above calculations of <img class="formulaInl" alt="$R$" src="form_29.png"/>, <img class="formulaInl" alt="$w_x$" src="form_2.png"/> and <img class="formulaInl" alt="$w_z$" src="form_3.png"/>, the <img class="formulaInl" alt="$(x,y,z)$" src="form_30.png"/> position of the object can be calculated as seen in the <a class="el" href="index.html#Figure_geometry">Figure_geometry</a>, </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ x = R\cos(\phi)\sin(\theta) = R\frac{w_x}{\pi}, z = R\sin(\phi) = R\frac{w_z}{\pi}, y = \sqrt{R^2-x^2-z^2} \]" src="form_31.png"/>
</p>
<p> The computed <img class="formulaInl" alt="$(x,y,z)$" src="form_30.png"/> and azimuth peak for each object are populated in their respective positions in <a class="el" href="struct_mmw_demo___data_path_obj__t.html#ace23b31b37f92fccf90a9fee64f4c3c6">MmwDemo_DataPathObj::objOut</a> which is then shipped out on the UART port (<a class="el" href="main_8c.html#ac3a90335aea273ffb5d4cc76d780a55d">MmwDemo_transmitProcessedOutput</a>). To be able to detect two objects at the same range-doppler index but at different angle, search for the 2nd peak in the azimuth FFT and compare its height relative to the first peak height, and if detected, create new object in the list with the same range/Doppler indices, and repeat above steps to calculate (x,y,z) coordinates. To enable/disable the two peak detection or to change the threshold for detection, refer to <a class="el" href="data__path_8h.html#acab7c9fc6139e9d8192c8b9b8ed528ed">MMWDEMO_AZIMUTH_TWO_PEAK_DETECTION_ENABLE</a> and <a class="el" href="data__path_8h.html#a518239edb48a7db80acedb6e20275cc6">MMWDEMO_AZIMUTH_TWO_PEAK_THRESHOLD_SCALE</a>.</p>
<h2><a class="anchor" id="output"></a>
Output information sent to host</h2>
<p>Please refer to this section in the doxygen documentation of the xwr16xx mmw Demo because this is part of a unified interface. For the stats information, the following diagram applies for 14xx.</p>
<div class="image">
<img src="margins_xwr14xx.png" alt="margins_xwr14xx.png"/>
<div class="caption">
Margins and R4F CPU loading</div></div>
 <h2><a class="anchor" id="calibration"></a>
Range Bias and Rx Channel Gain/Offset Measurement and Compensation</h2>
<p>Please refer to this section in the doxygen documentation of the xwr16xx mmw Demo. The differences are as follows:</p><ol type="1">
<li>For the scheme <a class="el" href="data__path_8h.html#a8db0f12d3b1bb9c6d76e0e5dc26ab1b9a88ff48379dbdf4a48b2a8b1c53799ec5">DATA_PATH_CHAIN_COMBINED_LOGMAG</a>, because we are computing azimuth static heat map on 1D FFT (a limitation that will be removed in a future release), the calibration procedure will not be immune to motion in the scene, hence during calibration caution must exercised to ensure there are no moving objects in the background.</li>
<li>The azimuth static heat map itself is not corrected, this limitation will be removed in a future release.</li>
</ol>
<h2><a class="anchor" id="datapathConfig"></a>
Data Path - Notes on configuration and synchronization.</h2>
<ul>
<li>EDMA: For all of the data path processing, the demo uses non-overlapping EDMA resources (chain channels, link parameter sets etc) so that all EDMA configuration only needs to be done once (<a class="el" href="data__path_8c.html#a0e52fb3cf034b7d616c21188d5b9ad40">MmwDemo_config1D_EDMA</a>, <a class="el" href="data__path_8c.html#a62dacf47c79440026d89c723a3a1edea">MmwDemo_config2D_EDMA</a> and <a class="el" href="data__path_8c.html#a9ad88b233bba1ab089e884993ae4d02d">MmwDemo_configCFAR_EDMA</a> &ndash; called in <a class="el" href="data__path_8h.html#a1f322283a6721ee9d95a70b23e6fc219">MmwDemo_dataPathConfigCommon</a>). The channel resources involved in chaining are using the channels that are not tied to any hardware entity on the SoC, these are ones that have suffix EDMA*_FREE_&lt;n&gt; as specified in the <a class="el" href="sys__common_8h.html">sys_common.h</a> file. An alternative implementation that is more EDMA resource constrained may overlap resources among 1D, 2D and CFAR processing at the cost of processing cycles to reconfigure the EDMA in real-time. The R4F CPU programs the EDMA through the utility APIs in <a class="el" href="config__edma__util_8h.html">config_edma_util.h</a>, which in turn invoke the EDMA driver configuration APIs to program the EDMA. The R4F CPU gets notified of the channels on which it desires completion notification through an application call-back function provided to the EDMA driver and in this function it posts the semaphore on which it can wait for completion. Present implementation shows a single call back function (<a class="el" href="data__path_8c.html#af881356797d361d667055dbb4ed8aa08">MmwDemo_EDMA_transferCompletionCallbackFxn</a>) which posts different semaphores (<a class="el" href="struct_mmw_demo___data_path_obj__t.html#a8ff0bea533d3217a27678ee6e4fce216">MmwDemo_DataPathObj::EDMA_1Ddone_semHandle</a>, <a class="el" href="struct_mmw_demo___data_path_obj__t.html#a6f8cf99deb05920fa05e28e2862bfc92">MmwDemo_DataPathObj::EDMA_2Ddone_semHandle</a> and <a class="el" href="struct_mmw_demo___data_path_obj__t.html#a712cb6634bd09b16143234eee74e186a">MmwDemo_DataPathObj::EDMA_CFARdone_semHandle</a>) based on which channel (or rather transfer completion codes) were indicated complete by the EDMA driver. The R4F CPU can pend on the semaphores in the data path processing chain.</li>
<li>HWA: The window RAMs are configured for the 1D and 2D FFT only once (in <a class="el" href="data__path_8h.html#a1f322283a6721ee9d95a70b23e6fc219">MmwDemo_dataPathConfigCommon</a>). The 1D window is currently chosen to be Blackman and the 2D is chosen to be Hanning window. This may be made configurable in future. Currently, HWA PARAMs are non-overlapping among the various processing stages. So they could be configured only once like the EDMA case, but current code shows them being re-configured in the real-time along with setting the start,end indices and the loop count required for each processing stage (<a class="el" href="data__path_8h.html#ace4c5b918f8614a44af79c92a51585c8">MmwDemo_config1D_HWA</a>, <a class="el" href="data__path_8c.html#ae6b40228170cf4f048609578cb913a87">MmwDemo_config2D_HWA</a>, <a class="el" href="data__path_8c.html#a10cd2071c5bd1634aa9501b99d8b11fe">MmwDemo_configCFAR_HWA</a> and <a class="el" href="data__path_8h.html#a25cda24aa787fd20bb4e9962df3aafaa">MmwDemo_configAngleEstimation_HWA</a>). The R4F CPU gets notified of HWA completion through an application supplied semaphore (<a class="el" href="struct_mmw_demo___data_path_obj__t.html#ae7466a3bd509c6871aa2bbbb0475b0b1">MmwDemo_DataPathObj::HWA_done_semHandle</a>) to the HWA driver and it can pend on this semaphore. There are utility APIs provided in <a class="el" href="config__hwa__util_8h.html">config_hwa_util.h</a> that are used to by the application to program the HWA.</li>
</ul>
<h2><a class="anchor" id="designNotes"></a>
Data Path Design Notes</h2>
<h3><a class="anchor" id="L3"></a>
Heap</h3>
<p>The data buffer arrangement in L3 heap is shown in the following diagram. The buffers are allocated through <a class="el" href="data__path_8h.html#ab46a1f7b2b1eea79d22b428e311af4a3">MmwDemo_memPoolAlloc</a>. The size of each segment is determined at runtime based on configurations.</p><ul>
<li>radarCube size = numRangeBins * numDopplerBins * numTxAntennas * numRxAntennas * 4 bytes</li>
<li>rangeDopplerLogMagMatrix Size = numRangeBins * numDopplerBins * 2 bytes</li>
<li>cfarDetectionOut Size = <a class="el" href="data__path_8h.html#aacb091770bbe78cbd1ea4a03d8145468">MMW_MAX_OBJ_OUT</a> * sizeof(<a class="el" href="data__path_8h.html#a16f0ee49e3b6e93b1911bddbb137ec8c">cfarDetOutput_t</a>)</li>
<li>azimuthStaticHeatMap Size = numRangeBins * numVirtualAntAzim * 4 bytes (if azimuth heatmap is enabled)</li>
</ul>
<div class="image">
<img src="data_buffers_layout.png" alt="data_buffers_layout.png"/>
<div class="caption">
Data buffers layout arrangement</div></div>
<p>.</p>
<h3><a class="anchor" id="scaling"></a>
Scaling</h3>
<p>The HWA uses 24-bit fixed point arithmetic for the data path processing. In order to prevent overflows in the FFT processing, the scaling factors have to be set appropriately in the HWA configuration. The HWA has up to 10 stages of processing with ability to scale by 1/2 for each stage.</p><ul>
<li>1D processing: If the HWA's FFT scale is set to <img class="formulaInl" alt="$\frac{1}{2^k}$" src="form_32.png"/> where <img class="formulaInl" alt="$k$" src="form_33.png"/> is the number of stages for which the scaling is enabled, and input to the FFT were a pure tone at one of the bins, then the output magnitude of the FFT at that bin will be <img class="formulaInl" alt="$\frac{N}{2^k}$" src="form_34.png"/> ( <img class="formulaInl" alt="$N$" src="form_35.png"/> is the FFT order) times the input tone amplitude (because tone is complex, this implies that the individual real and imaginary components will also be amplified by a maximum of this scale). Because we do a Blackman window before the FFT, the overall scale is about 1/2.4 of the FFT scale. This means for example for 256 point FFT, the windowing + FFT scale will be <img class="formulaInl" alt="$\frac{106.7}{2^k}$" src="form_36.png"/>. For k=2 which is currently how it is in the implementation (no matter the FFT order), this will be 26.7. Therefore, the ADC output when it is a pure tone should not exceed +/-2^15/26.7 = 1228 for the I and Q components (even though HWA is internally 24-bit, the FFT output is stored as 16-bit before 2D processing, hence 2^15). The XWR14xx EVM when presented with a strong single reflector reasonably close to it (with Rx dB gain of 30 dB in the chirp profile) shows ADC samples to be a max of about 2000 and while this exceeds the 1228 maximum, is not a pure tone, the energy of the FFT is seen in other bins also and the solution still works well and detects the strong object.</li>
<li>2D processing: For the 2D FFT, given that the input is the output of 1D FFT that can amplify its input as mentioned in previous section, it is more appropriate to use full scale. So currently in the implementation, scaling is enabled for all stages of the FFT except for the first stage because of Hanning window related scaling by 1/2.</li>
</ul>
<h3><a class="anchor" id="lvds"></a>
LVDS Streaming</h3>
<p>LVDS Streaming is unverified code. LVDS streaming conflicts with data path processing and should not be used.</p>
<h1><a class="anchor" id="memoryUsage"></a>
Memory Usage</h1>
<h2><a class="anchor" id="memUsageSummary"></a>
Memory usage summary</h2>
<p>The table below shows the usage of various memories available on the device across the demo application and other SDK components. The table is generated using the demo's map file and applying some mapping rules to it to generate a condensed summary. For the mapping rules, please refer to <a href="../../demo_mss_mapping.txt">demo_mss_mapping.txt</a>. The numeric values shown here represent bytes. Refer to the <a href="../../xwr14xx_mmw_demo_mss_mem_analysis_detailed.txt">xwr14xx_mmw_demo_mss_mem_analysis_detailed.txt</a> for detailed analysis of the memory usage across drivers and control/alg components and to <a href="../../demo_mss_mapping_detailed.txt">demo_mss_mapping_detailed.txt</a> for detailed mapping rules .</p>
<div class="fragment"><div class="line">                                   OVERVIEW                                    </div><div class="line">Memory                              Used               Total        Percent Used</div><div class="line">--------------------------------------------------------------------------------</div><div class="line">DATA_RAM                           50744               65536              77.43%</div><div class="line">HWA_RAM                            65536               65536             100.00%</div><div class="line">L3_RAM                            393216              393216             100.00%</div><div class="line">PROG_RAM                          118431              130816              90.53%</div><div class="line">VECTORS                               60                 256              23.44%</div><div class="line"></div><div class="line"></div><div class="line">                            Type           DATA_RAM      HWA_RAM       L3_RAM     PROG_RAM      VECTORS</div><div class="line">--------------------------------------------------------------------------------</div><div class="line">(.cinit..l3ram.load)        unknown               0            0            0            8            0</div><div class="line">APP                         code              11788            0            0        58214           60</div><div class="line">APP                         heap              34816            0       393216            0            0</div><div class="line">APP                         hw_mem                0        65536            0            0            0</div><div class="line">BIOS                        code                  4            0            0        17210            0</div><div class="line">COMPONENTS_CORE             code               2088            0            0        28294            0</div><div class="line">COMPONENTS_OPTIONAL         code                848            0            0        13374            0</div><div class="line">linker-generated            linker             1200            0            0          169            0</div><div class="line">linker-generated            unknown               0            0            0         1162            0</div></div><!-- fragment --><h2>Note on L3 memory and overlay </h2>
<p>A quick look at the L3_SRAM column will show that the total of that column exceeds the total physical memory available on the device. The reason is that we use the code-data overlay mechanism to virtually extend the available memory on the device. One-time startup code is overlaid with the radar cube. At startup, the application code accesses these functions to perform one-time setup functionality. Beyond that point, application code does not have a need to access these functions again and hence switches to access radarCube placed at the exact same location. Refer to the linker command file of the demo on the mechanics of this overlay technique. </p>
</div></div><!-- contents -->
<hr size="1"><small>
Copyright  2018, Texas Instruments Incorporated</small>
</body>
</html>
